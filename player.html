<!DOCTYPE html>
<html>
  <head>
    <script src="inputtextsample.js" type="text/javascript"></script>
    <script type="text/javascript">
      const range = (start, end) => [...Array(end + 1).keys()].slice(start);

      function main() {
        const frameEvents = window.frameEvents;

        function scheduleFrameEvents(frameEvents) {
          const absoluteFrameCountToScheduledFrameEvents = {};
          let currentFrameCount = 1;

          frameEvents.forEach(function (frameEvent) {
            const objectId = frameEvent.objectId ? frameEvent.objectId : "auto" + Math.random(); // 値が未指定の場合もframeEvent内で一律で持てるとよい

            // この分岐はなくても動くが無駄なオブジェクトが生成されるのを避けたい
            if (
              frameEvent.type !== "doNothing" &&
              frameEvent.type !== "defineLabel"
            ) {
              if (frameEvent.frameCount === 0) {
                if (
                  !absoluteFrameCountToScheduledFrameEvents[currentFrameCount]
                ) {
                  absoluteFrameCountToScheduledFrameEvents[currentFrameCount] =
                    [];
                }

                absoluteFrameCountToScheduledFrameEvents[
                  currentFrameCount
                ].push({
                  event: frameEvent,
                  frameCountInEvent: 0, // 便宜上0にしておく
                  objectId: objectId,
                });
              } else {
                range(0, frameEvent.frameCount - 1).forEach(function (
                  frameCountInEvent,
                  index
                ) {
                  const fixedFrameCountInEvent = currentFrameCount + index;
                  if (
                    !absoluteFrameCountToScheduledFrameEvents[
                      fixedFrameCountInEvent
                    ]
                  ) {
                    absoluteFrameCountToScheduledFrameEvents[
                      fixedFrameCountInEvent
                    ] = [];
                  }
                  absoluteFrameCountToScheduledFrameEvents[
                    fixedFrameCountInEvent
                  ].push({
                    event: frameEvent,
                    frameCountInEvent: index + 1,
                    objectId: objectId,
                  });
                });
              }
            }

            currentFrameCount += frameEvent.frameCount;
          });
          return absoluteFrameCountToScheduledFrameEvents;
        }

        const absoluteFrameCountToScheduledFrameEvents =
          scheduleFrameEvents(frameEvents);

        // 最後まで達したら最初に戻るため
        const lastFrameCount = Math.max.apply(
          null,
          Object.keys(absoluteFrameCountToScheduledFrameEvents)
        );
        const depthToLayerWrapper = {};

        function setLayoutOptionsToElement(element, layoutOptions) {
          element.style.position = "absolute";
          element.style.width = `${layoutOptions.width}px`;
          element.style.height = `${layoutOptions.height}px`;
          element.style.left = `${layoutOptions.x}px`;
          element.style.top = `${layoutOptions.y}px`;
        }

        function setOnClickActionListener(element, action, handleAction) {
          if (!action) {
            return;
          }
          element.addEventListener("click", function () {
            console.log("click", element, action);
            handleAction(action);
          });
        }

        function render(depthToLayer, { handleAction }) {
          const root = document.getElementById("root");

          // TODO: ここの設定値も外から持ってくる
          root.style.border = "solid 1px #000";
          root.style.width = "640px";
          root.style.height = "480px";
          root.style.position = "relative";
          root.style.overflow = "hidden";

          // TODO: 列挙順がdepth順になっていることを保証する
          Object.keys(depthToLayer).forEach(function (depth) {
            const layer = depthToLayer[depth];

            if (!depthToLayerWrapper[depth]) {
              const newWrapper = document.createElement("div");
              // TODO: ここでposition: absolute, zindex, width, height設定
              root.appendChild(newWrapper);
              depthToLayerWrapper[depth] = newWrapper;
            }

            // TODO: ここで必要なければremoveしない実装にできるとよい
            const wrapper = depthToLayerWrapper[depth];
            const object = layer && layer.object;
            if (!object) {
              if (wrapper.firstChild) {
                wrapper.removeChild(wrapper.firstChild);
              }
              return;
            }

            let targetElement = null;
            if (object.useCache) {
              const candidateElement = wrapper.firstChild;
              if (candidateElement.dataset.objectId === object.objectId) {
                targetElement = candidateElement;
                // console.log('cache利用');
              }
            }
            if (!targetElement) {
              if (wrapper.firstChild) {
                wrapper.removeChild(wrapper.firstChild);
              }
              if (object.type === "image") {
                targetElement = document.createElement("img");
              } else if (object.type === "text") {
                targetElement = document.createElement("div");
              }
            }

            if (object.type === "image") {
              targetElement.src = object.image.source;
              targetElement.dataset.objectId = object.objectId;
              wrapper.appendChild(targetElement);
              setLayoutOptionsToElement(targetElement, object.layoutOptions);
              setOnClickActionListener(
                targetElement,
                object.onClickAction,
                handleAction
              );
            } else if (object.type === "text") {
              targetElement.dataset.objectId = object.objectId;
              targetElement.innerText = object.text.content;
              wrapper.appendChild(targetElement);
              const layoutOptions = object.layoutOptions;
              setLayoutOptionsToElement(targetElement, object.layoutOptions);
              setOnClickActionListener(
                targetElement,
                object.onClickAction,
                handleAction
              );

              if (object.text.borderWidth) {
                targetElement.style.borderWidth = `${object.text.borderWidth}px`;
              }
              if (object.text.borderStyle) {
                targetElement.style.borderStyle = object.text.borderStyle;
              }
              if (object.text.borderColor) {
                targetElement.style.borderColor = object.text.borderColor;
              }
            }
          });
        }

        function calcualteLabelFrameCount(frameEvents) {
          const labelToFrameCount = {};
          let currentFrameCount = 1;
          frameEvents.forEach(function (frameEvent) {
            if (frameEvent.type === "defineLabel") {
              const label = frameEvent.defineLabel.label;
              labelToFrameCount[label] = currentFrameCount;
            }

            currentFrameCount += frameEvent.frameCount;
          });
          return labelToFrameCount;
        }

        const depthToLayer = {};
        const labelToFrameCount = calcualteLabelFrameCount(frameEvents);
        let currentFrameCount = 1;
        let jumpToFrameCount = null;
        let isPlaying = true;
        console.log(absoluteFrameCountToScheduledFrameEvents);
        console.log(labelToFrameCount);

        const userVariables = {};
        const context = {
          play() {
            isPlaying = true;
          },
          stop() {
            isPlaying = false;
          },
          gotoAndPlay(destination) {
            // TODO: 本当はここでバリデーションが必要
            if (typeof destination === "string") {
              jumpToFrameCount = Number(labelToFrameCount[destination]);
            } else {
              jumpToFrameCount = destination;
            }
            isPlaying = true;
          },
          eraseLayers(depths) {
            if (depths.includes("all")) {
              Object.keys(depthToLayer).forEach(function (eachDepth) {
                depthToLayer[eachDepth] = undefined;
              });
            } else {
              depths.forEach(function (eachDepth) {
                depthToLayer[eachDepth] = undefined;
              });
            }
          },
          setUserVariable(key, value) {
            userVariables[key] = JSON.stringify(value);
          },
          getUserVariable(key) {
            if (userVariables[key] !== undefined) {
              return JSON.parse(userVariables[key]);
            } else {
              return undefined;
            }
          },
        };
        function handleAction(action) {
          // stop, gotoAndPlayはframeCountが1になる
          // defineLabel, eraseLayersはframeCountは0
          if (action.type === "eraseLayers") {
            const depths = action.eraseLayers.depths;
            context.eraseLayers(depths);
          } else if (action.type === "stop") {
            context.stop();
          } else if (action.type === "play") {
            context.play();
          } else if (action.type === "gotoAndPlay") {
            context.gotoAndPlay(action.gotoAndPlay.destination);
          } else if (action.type === "executeScript") {
            const func = new Function("context", action.executeScript.content);
            func(context);
          }
        }
        setInterval(function () {
          if (!isPlaying) {
            return false;
          }

          // 最後まで行ったら最初に戻る（判定これでいいのかな？）
          if (currentFrameCount > lastFrameCount) {
            currentFrameCount = 1;
          }

          // 飛び先が指定されていたらそっちにいく
          if (jumpToFrameCount !== null) {
            currentFrameCount = jumpToFrameCount;
            jumpToFrameCount = null;
          }

          console.log(currentFrameCount);

          const currentScheduledFrameEvents =
            absoluteFrameCountToScheduledFrameEvents[currentFrameCount] || [];

          currentScheduledFrameEvents.forEach(function (scheduledFrameEvent) {
            const event = scheduledFrameEvent.event;
            const depth = event.depth;

            if (event.type === "executeAction") {
              console.log("executeAction", event.executeAction);
              handleAction(event.executeAction);
            }

            if (event.type === "putImage" || event.type === "putText") {
              let objectBase = null;
              // ここの種別は、画像・テキスト・HTML要素・音声・スプライトなどを想定
              if (event.type === "putImage") {
                objectBase = {
                  type: "image",
                  image: {
                    source: event.putImage.source,
                  },
                  onClickAction: event.onClickAction,
                  objectId: scheduledFrameEvent.objectId,
                };
              } else if (event.type === "putText") {
                objectBase = {
                  type: "text",
                  text: {
                    ...event.putText,
                  },
                  onClickAction: event.onClickAction,
                  objectId: scheduledFrameEvent.objectId,
                };
              }

              if (scheduledFrameEvent.frameCountInEvent <= 1) {
                // 0または1
                // TODO: ここでdepthあるかの判定
                depthToLayer[depth] = {
                  object: {
                    ...objectBase,
                    useCache: false,
                    layoutOptions: event.layoutOptions,
                  },
                };
              } else {
                const before = event.layoutOptions;
                const after = event.lastKeyFrame.layoutOptions;

                // TODO: ここでdepthあるかの判定
                depthToLayer[depth] = {
                  object: {
                    ...objectBase,
                    useCache: true,
                    layoutOptions: {
                      x:
                        before.x +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.x - before.x)) /
                          event.frameCount,
                      y:
                        before.y +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.y - before.y)) /
                          event.frameCount,
                      width:
                        before.width +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.width - before.width)) /
                          event.frameCount,
                      height:
                        before.height +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.height - before.height)) /
                          event.frameCount,
                    },
                  },
                };
              }
            }

            render(depthToLayer, { handleAction });
          });
          currentFrameCount += 1;
        }, 100);
      }

      window.onload = function () {
        main();
      };
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
