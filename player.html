<!DOCTYPE html>
<html>
  <head>
    <script src="slideshowcontrol.js" type="text/javascript"></script>
    <script type="text/javascript">
      const range = (start, end) => [...Array(end + 1).keys()].slice(start);

      function main() {
        const frameEvents = window.frameEvents;

        function scheduleFrameEvents(frameEvents) {
          const absoluteFrameCountToScheduledFrameEvents = {};
          let currentFrameCount = 1;

          frameEvents.forEach(function (frameEvent) {
            const objectId = "dummy";
            if (frameEvent.frameCount === 0) {
              if (
                !absoluteFrameCountToScheduledFrameEvents[currentFrameCount]
              ) {
                absoluteFrameCountToScheduledFrameEvents[currentFrameCount] =
                  [];
              }

              absoluteFrameCountToScheduledFrameEvents[currentFrameCount].push({
                event: frameEvent,
                frameCountInEvent: 0, // 便宜上0にしておく
                objectId: objectId,
              });
            } else {
              range(0, frameEvent.frameCount - 1).forEach(function (
                frameCountInEvent,
                index
              ) {
                const fixedFrameCountInEvent = currentFrameCount + index;
                if (
                  !absoluteFrameCountToScheduledFrameEvents[
                    fixedFrameCountInEvent
                  ]
                ) {
                  absoluteFrameCountToScheduledFrameEvents[
                    fixedFrameCountInEvent
                  ] = [];
                }
                if (frameEvent.type !== "doNothing") {
                  // この分岐はなくても動くが無駄なオブジェクトが生成されるのを避けたい
                  absoluteFrameCountToScheduledFrameEvents[
                    fixedFrameCountInEvent
                  ].push({
                    event: frameEvent,
                    frameCountInEvent: index + 1,
                    objectId: objectId,
                  });
                }
              });
            }
            currentFrameCount += frameEvent.frameCount;
          });
          return absoluteFrameCountToScheduledFrameEvents;
        }

        const absoluteFrameCountToScheduledFrameEvents =
          scheduleFrameEvents(frameEvents);

        // 最後まで達したら最初に戻るため
        const lastFrameCount = Math.max.apply(
          null,
          Object.keys(absoluteFrameCountToScheduledFrameEvents)
        );

        const depthToLayerWrapper = {};
        const objectIdToElement = {}; // TODO: 要素のキャッシュを実装する

        function setLayoutOptionsToElement(element, layoutOptions) {
          console.log(layoutOptions);
          element.style.position = "absolute";
          element.style.width = `${layoutOptions.width}px`;
          element.style.height = `${layoutOptions.height}px`;
          element.style.left = `${layoutOptions.x}px`;
          element.style.top = `${layoutOptions.y}px`;
        }

        function render(depthToLayer) {
          const root = document.getElementById("root");

          // TODO: ここの設定値も外から持ってくる
          root.style.border = "solid 1px #000";
          root.style.width = "640px";
          root.style.height = "480px";
          root.style.position = "relative";
          root.style.overflow = "hidden";

          // TODO: 列挙順
          Object.keys(depthToLayer).forEach(function (depth) {
            const layer = depthToLayer[depth];

            if (!depthToLayerWrapper[depth]) {
              const newWrapper = document.createElement("div");
              // TODO: ここでposition: absolute, zindex, width, height設定
              root.appendChild(newWrapper);
              depthToLayerWrapper[depth] = newWrapper;
            }

            // TODO: ここで必要なければremoveしない実装にできるとよい
            const wrapper = depthToLayerWrapper[depth];
            while (wrapper.firstChild) {
              wrapper.removeChild(wrapper.firstChild);
            }

            if (!layer) {
              return;
            }
            const object = layer.object;
            if (!object) {
              return;
            }
            console.log(object);

            if (object.type === "image") {
              const imageElement = document.createElement("img");
              imageElement.src = object.image.source;
              wrapper.appendChild(imageElement);
              setLayoutOptionsToElement(imageElement, object.layoutOptions);
            } else if (object.type === "text") {
              const textElement = document.createElement("div");
              textElement.innerText = object.text.label;
              wrapper.appendChild(textElement);
              const layoutOptions = object.layoutOptions;
              console.log(layoutOptions);
              setLayoutOptionsToElement(textElement, object.layoutOptions);

              if (object.text.borderWidth) {
                textElement.style.borderWidth = `${object.text.borderWidth}px`;
              }
              if (object.text.borderStyle) {
                textElement.style.borderStyle = object.text.borderStyle;
              }
              if (object.text.borderColor) {
                textElement.style.borderColor = object.text.borderColor;
              }
            }
          });
        }

        const depthToLayer = {};
        let currentFrameCount = 0;
        let isPlaying = true;

        const context = {
          play() {
            isPlaying = true;
          },
          stop() {
            isPlaying = false;
          },
          eraseLayers(depths) {
            if (depths.includes("all")) {
              Object.keys(depthToLayer).forEach(function (eachDepth) {
                depthToLayer[eachDepth] = undefined;
              });
            } else {
              depths.forEach(function (eachDepth) {
                depthToLayer[eachDepth] = undefined;
              });
            }
          },
        };
        function handleAction(action) {
          if (action.type === "eraseLayers") {
            const depths = action.eraseLayers.depths;
            context.eraseLayers(depths);
          } else if (action.type === "stop") {
            context.stop();
          }
        }
        setInterval(function () {
          if (!isPlaying) {
            return false;
          }

          currentFrameCount += 1;
          // 最後まで行ったら最初に戻る（判定これでいいのかな？）
          if (currentFrameCount > lastFrameCount) {
            currentFrameCount = 0;
          }

          const currentScheduledFrameEvents =
            absoluteFrameCountToScheduledFrameEvents[currentFrameCount];
          if (!currentScheduledFrameEvents) {
            // 何もしないフレーム
            return;
          }

          currentScheduledFrameEvents.forEach(function (scheduledFrameEvent) {
            const event = scheduledFrameEvent.event;
            const depth = event.depth;

            if (event.type === "executeAction") {
              handleAction(event.executeAction);
            }

            if (event.type === "putImage" || event.type === "putText") {
              let objectBase = null;
              // ここの種別は、画像・テキスト・HTML要素・音声・スプライトなどを想定
              if (event.type === "putImage") {
                objectBase = {
                  type: "image",
                  image: {
                    source: event.putImage.source,
                  },
                };
              } else if (event.type === "putText") {
                objectBase = {
                  type: "text",
                  text: {
                    ...event.putText,
                  },
                };
              }

              if (scheduledFrameEvent.frameCountInEvent <= 1) {
                // 0または1
                // TODO: ここでdepthあるかの判定
                depthToLayer[depth] = {
                  object: {
                    ...objectBase,
                    layoutOptions: event.layoutOptions,
                  },
                };
              } else {
                const before = event.layoutOptions;
                const after = event.lastKeyFrame.layoutOptions;

                // TODO: ここでdepthあるかの判定
                // TODO: ここでtypeの判定
                depthToLayer[depth] = {
                  object: {
                    ...objectBase,
                    layoutOptions: {
                      x:
                        before.x +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.x - before.x)) /
                          event.frameCount,
                      y:
                        before.y +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.y - before.y)) /
                          event.frameCount,
                      width:
                        before.width +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.width - before.width)) /
                          event.frameCount,
                      height:
                        before.height +
                        (scheduledFrameEvent.frameCountInEvent *
                          (after.height - before.height)) /
                          event.frameCount,
                    },
                  },
                };
              }
            }

            render(depthToLayer);
          });
        }, 100);
      }

      window.onload = function () {
        main();
      };
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
